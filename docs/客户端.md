#### grpc.DialContext

    DialContext 在配置这两项 grpc.FailOnNonTempDialError(true), grpc.WithReturnConnectionError()后，将表现出以下行为
        1）遇到非临时错误时会立即返回。返回的错误值将包含遇到的错误详细信息。
        2）如果遇到非临时错误，它只会尝试建立连接10秒，该函数将返回非临时错误详细信息的错误值

#### 处理瞬态故障

    使用gRPC的最大好处之一是客户端可以进行多次调用，而不必为每个请求创建新通道。然而这也意味着默认情况下网络连接是长期存在的，因此容易出现故障。幸运的是，gRPC定义了等到就绪（wait for ready）语义，我们可以在调用gRPC方法时向起传递额外的参数grpc.WaitForReady(一个grpc.CallOption值)，这样在方法调用时，如果未建立到服务器的连接，它会先尝试建立连接，然后调用RPC方法。这样，客户端执行完一次调用，再执行下一次调用前，服务端退出了，下一次调用会会阻塞去连接服务端，连接成功后继续调用，连上之前会一直阻塞。
        grpc.WaitForReady对与一元RPC方法，这在处理临时连接失败时很有用。但是对于流RPC方法调用，这意味着grpc.WaitForReady（）仅在创建流时有用。如果创建流后出现网络问题怎么办？
    流模式的客户端：
        在服务端触发超时、panic等情况是，客户端需要重启创建流
        stream.Recv()返回的错误，如果是io.EOF（流正常终止时会返回该错误，因此其他错误都是非正常错误），就是正常完成，其他错误就需要重新创建流
        流意外中断（例如网络故障）stream.Send()也会返回io.EOF错误, 因此区分中场终止和异常终止是很棘手的。不过我们可以进一步通过stream.RecvMsg()的错误来判断，如果错误非nil就推断为异常终止，需要重新创建流。
    客户端超时处理
        一元模式：
            在调用一元方法时，传入带超时的context
        流模式：
            给创建流的方法，用context超时配合select处理, 也就是对创建流的方法检测是否超时

#### RPC方法调用数量

    在客户端和服务端建立连接之后，可同时进行多个RPC方法调用。默认情况下在任何给定的时间点，这被限制为100个活动RPC方法调用。
    客户端和服务端进程之间，只有一个连接。在生产场景中，一个gRPC服务很可能有多个服务器后端，因此每个服务器后端总有一个连接。可以给每个RPC方法调用都执行负载均衡（可利用Nginx等）